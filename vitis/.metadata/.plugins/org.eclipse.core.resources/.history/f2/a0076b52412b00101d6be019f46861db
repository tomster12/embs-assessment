#include <stdint.h>
#include "xil_printf.h"
#include "xil_cache.h"
#include "xtoplevel.h"
#include "xuartps_hw.h"
#include "FreeRTOS.h"
#include "task.h"
#include "semphr.h"
#include "netif/xadapter.h"
#include "lwip/dhcp.h"
#include "lwip/sockets.h"
#include "lwipopts.h"
#include "zybo_z7_hdmi/display_ctrl.h"

// ================================= DECLARATION =================================

#define THREAD_STACKSIZE 1024
#define FRAME_RES (1440*900) // 1440x900 based on 4x8 bits for 32-bit colours
#define FRAME_STRIDE (1440*4)
#define UDP_RECV_BUF_MAX (1 << 11) // 2048 bytes (max response is 8 + 240 * 6 = 1448 bytes)
#define UART_IN_BUF_MAX (1 << 9) // 512 bytes
#define RECV_PORT 51050
#define WORLD_SERVER_PORT 51050
#define WS_IPV4_ADDR(v) IP4_ADDR(&(v), 192, 168, 10, 1)
#define WORLD_MAX_WALLS 240
#define WORLD_MAX_WAYPOINTS 16
#define WORLD_MAX_SIZE 500

// RAM Layout (32-bit words)
// -----------------------------
// [0]     = world_size
// [1]     = waypoint_count
// [2..A]  = waypoints (WORLD_MAX_WAYPOINTS)
// [A..B]  = world bitmask (1 bit per cell, row-major order, WORLD_MAX_SIZE * WORLD_MAX_SIZE)
//
// For a 500x500 world this is meta (2 words) + waypoints (12 words) + grid (ceil(250000 / 32) = 7813 words) 7827 words

#define HW_META_WORDS 2
#define HW_WAYPOINT_WORDS WORLD_MAX_WAYPOINTS
#define HW_WORLD_WORDS ((WORLD_MAX_SIZE * WORLD_MAX_SIZE + 31) / 32)
#define HW_MAX_WORDS (HW_META_WORDS + HW_WAYPOINT_WORDS + HW_WORLD_WORDS)

typedef struct __attribute__((packed)) { uint8_t type; uint32_t seed; uint16_t size; } WorldRequest; // Big-endian data required
typedef struct __attribute__((packed)) { uint16_t x; uint16_t y; uint8_t length; uint8_t direction; } WorldWall;
typedef struct __attribute__((packed)) { uint16_t x; uint16_t y; } WorldWaypoint;
typedef struct __attribute__((packed)) { uint8_t type; uint32_t seed; uint16_t size; uint8_t num_walls; WorldWall walls[WORLD_MAX_WALLS]; } WorldWalls;
typedef struct __attribute__((packed)) { uint8_t type; uint32_t seed; uint16_t size; uint8_t num_waypoints; WorldWaypoint waypoints[WORLD_MAX_WAYPOINTS]; } WorldWaypoints;
typedef struct __attribute__((packed)) { uint8_t type; uint32_t seed; uint16_t size; uint32_t answer; } WorldSolutionAttempt;
typedef struct __attribute__((packed)) { uint8_t type; uint32_t seed; uint16_t size; uint8_t answer; } WorldSolutionResponse;

TaskHandle_t h_lwip_startup_task, h_lwip_dhcp_task, h_lwip_input_task, h_app_task;
uint8_t my_mac_addr[] = { 0x00, 0x11, 0x22, 0x33, 0x00, 0x52 };
struct netif my_net_if;
struct udp_pcb *udp_pcb;
ip_addr_t world_server_ip;
SemaphoreHandle_t udp_recv_sem;
uint8_t udp_recv_buf[UDP_RECV_BUF_MAX];
uint16_t udp_recv_buf_len;
char uart_in_buf[UART_IN_BUF_MAX];
uint16_t uart_in_buf_len;
WorldRequest world_request;
WorldWalls world_walls;
WorldWaypoints world_waypoints;
WorldSolutionAttempt world_solution_attempt;
WorldSolutionResponse world_solution_response;
XToplevel hls;
uint32_t hw_ram[HW_MAX_WORDS];
DisplayCtrl gx_dsp_ctrl;
uint32_t gx_frame_buf[DISPLAY_NUM_FRAMES][FRAME_RES] __attribute__((aligned(0x20))); // 2 frame buffers of size FRAME_RES aligned to 32-bits + pointers
void *gx_frame_ptrs[DISPLAY_NUM_FRAMES];

void lwip_init();
void lwip_startup_task();
void lwip_dhcp_task();
void print_ip(char *msg, ip_addr_t *ip);
void app_task();
int udp_send_msg(struct udp_pcb *pcb, const ip_addr_t *ip, uint16_t port, void *msg, uint16_t len);
void udp_recv_msg(void *arg, struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *addr, uint16_t port);
int udp_recv_block(uint16_t time);
void read_uart_line(char *msg);
int parse_world_walls(uint8_t *data, uint8_t data_len, WorldWalls *res);
int parse_world_waypoints(uint8_t *data, uint8_t data_len, WorldWaypoints *res);
int parse_world_solution_response(uint8_t *data, uint8_t data_len, WorldSolutionResponse *res);
int write_world_to_mem(uint32_t *ram, WorldWalls *walls, WorldWaypoints *waypoints);
int get_world_bit(uint32_t *world, uint16_t world_size, uint16_t x, uint16_t y);
int set_world_bit(uint32_t *world, uint16_t world_size, uint16_t x, uint16_t y, uint8_t value);
void debug_print_world_bitmap(uint32_t *ram);
int perform_pathfinding(uint32_t *ram);

// ================================= DEFINITION/MAIN =================================

int main(void) {
	xil_printf("\r\n\r\n==== Assessment program started ====\r\n");

	// Start lwip_startup_task which will startup lwip_main_task and app_task
	xTaskCreate(lwip_startup_task, "lwip_startup_task", THREAD_STACKSIZE, NULL, DEFAULT_THREAD_PRIO, &h_lwip_startup_task);

	// Then start scheduler and run until finished
	vTaskStartScheduler();

	xil_printf("====Assessment program finished ====\r\n");
	return 0;
}

// ================================= DEFINITION/NETWORK =================================

void lwip_startup_task()
{
	xil_printf("lwip_startup_task started\n\r");

	// Initialize LWIP
    lwip_init();

    // Set my network interface as default
    ip_addr_t ipaddr, netmask, gw;
	ipaddr.addr = 0;
	netmask.addr = 0;
	gw.addr = 0;

	if (!xemac_add(&my_net_if, &ipaddr, &netmask, &gw, my_mac_addr, XPAR_XEMACPS_0_BASEADDR)) {
    	xil_printf("Error adding network interface\n\r");
    	return;
    }

    netif_set_default(&my_net_if);
    netif_set_up(&my_net_if);

    // Start LWIP input task
    xTaskCreate((void(*)(void*))xemacif_input_thread, "xemacif_lwip_input_task", THREAD_STACKSIZE, &my_net_if, DEFAULT_THREAD_PRIO, &h_lwip_input_task);

    // Start DHCP task
    dhcp_start(&my_net_if);
    xTaskCreate(lwip_dhcp_task, "lwip_dhcp_task", THREAD_STACKSIZE, NULL, DEFAULT_THREAD_PRIO, &h_lwip_dhcp_task);

    // Wait until we get an IP address
    while (my_net_if.ip_addr.addr == 0) {
    	vTaskDelay(DHCP_FINE_TIMER_MSECS / portTICK_RATE_MS);
	}

	xil_printf("DHCP request success\n\r");
	print_ip("Board IP: ", &my_net_if.ip_addr);
	print_ip("Netmask : ", &my_net_if.netmask);
	print_ip("Gateway : ", &my_net_if.gw);

	// Start app task and close this task
	xTaskCreate(app_task, "app_task", THREAD_STACKSIZE, NULL, DEFAULT_THREAD_PRIO, &h_app_task);

    vTaskDelete(NULL);
}

void lwip_dhcp_task()
{
    // DCHP with periodic dhcp_fine_tmr and dhcp_coars_tmr
	xil_printf("lwip_dhcp_task started\n\r");

    int mscnt = 0;
    while (1) {
		vTaskDelay(DHCP_FINE_TIMER_MSECS / portTICK_RATE_MS);
		dhcp_fine_tmr();
		mscnt += DHCP_FINE_TIMER_MSECS;
		if (mscnt >= DHCP_COARSE_TIMER_SECS*1000) {
			dhcp_coarse_tmr();
			mscnt = 0;
		}
	}
}

void print_ip(char *msg, ip_addr_t *ip)
{
	xil_printf(msg);
	xil_printf("%d.%d.%d.%d\n\r", ip4_addr1(ip), ip4_addr2(ip), ip4_addr3(ip), ip4_addr4(ip));
}

// ================================= DEFINITION/APP =================================

void app_task() {
	xil_printf("app_task started\r\n");

	// Setup the main UDP PCB, server IP, and semaphores
	udp_pcb = udp_new();
	if (!udp_pcb) {
		xil_printf("Error creating UDP PCB\r\n");
		return;
	}

	WS_IPV4_ADDR(world_server_ip);
	udp_bind(udp_pcb, IP_ADDR_ANY, RECV_PORT);
	udp_recv(udp_pcb, udp_recv_msg, NULL);
	udp_recv_sem = xSemaphoreCreateBinary();

	Xil_DCacheDisable();
    XToplevel_Initialize(&hls, XPAR_TOPLEVEL_0_DEVICE_ID);
    XToplevel_Set_ram(&hls, (u32) hw_ram);

	xil_printf("App setup and communicating over port %d\r\n", RECV_PORT);

	while (1) {
		// Prompt the user for world params
		xil_printf("\r\n-- World Request --\r\n");
		read_uart_line("Seed: ");
		uint32_t world_seed = (uint32_t)strtoul((char *)uart_in_buf, NULL, 10);
		read_uart_line("World Size: ");
		uint16_t world_size = (uint16_t)strtoul((char *)uart_in_buf, NULL, 10);

		xil_printf(": Requesting world...\r\n");

		// Send request for world walls and parse
		world_request.type = 0x01;
		world_request.seed = htonl(world_seed);
		world_request.size = htons(world_size);
		if (udp_send_msg(udp_pcb, &world_server_ip, WORLD_SERVER_PORT, &world_request, sizeof(world_request)) == -1) continue;
		if (udp_recv_block(5000) == 1) continue;
		if (parse_world_walls(udp_recv_buf, udp_recv_buf_len, &world_walls) == -1) continue;

		// Send request for world waypoints and parse
		world_request.type = 0x03;
		if (udp_send_msg(udp_pcb, &world_server_ip, WORLD_SERVER_PORT, &world_request, sizeof(world_request)) == -1) continue;
		if (udp_recv_block(5000) == 1) continue;
		if (parse_world_waypoints(udp_recv_buf, udp_recv_buf_len, &world_waypoints) == -1) continue;

		// Try to solve the world using hardware acceleration
		xil_printf(": Pathfinding...\r\n");
		write_world_to_mem(hw_ram, &world_walls, &world_waypoints);
		debug_print_world_bitmap(hw_ram);
		perform_pathfinding(hw_ram);

		// Send world solution attempt
		world_solution_attempt.type =  0x05;
		world_solution_attempt.seed = htonl(world_seed);
		world_solution_attempt.size = htons(world_size);
		world_solution_attempt.answer = 69;
		if (udp_send_msg(udp_pcb, &world_server_ip, WORLD_SERVER_PORT, &world_solution_attempt, sizeof(world_solution_attempt)) == -1) continue;
		if (udp_recv_block(5000) == 1) continue;
		if (parse_world_solution_response(udp_recv_buf, udp_recv_buf_len, &world_solution_response) == -1) continue;

		xil_printf(": Final result: %lu\r\n", world_solution_response.answer);
	}

	// Finally free up this task
	vTaskDelete(NULL);
}

int udp_send_msg(struct udp_pcb *pcb, const ip_addr_t *ip, uint16_t port, void *msg, u16_t len) {
	struct pbuf *p = pbuf_alloc(PBUF_TRANSPORT, len, PBUF_RAM);
    if (p == NULL) {
    	xil_printf("Error: udp_send_msg pbuf == NULL");
    	return -1;
    }
    memcpy(p->payload, msg, len);
    xil_printf("(->) Sending %u bytes\r\n", len);
	udp_sendto(pcb, p, ip, port);
	pbuf_free(p);
    return 0;
}

void udp_recv_msg(void *arg, struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *addr, uint16_t port) {
    if (p == NULL) {
    	xil_printf("Error: udp_recv_msg pbuf == NULL");
    	return;
    }
    udp_recv_buf_len = p->len > UDP_RECV_BUF_MAX ? UDP_RECV_BUF_MAX : p->len;
    memcpy(udp_recv_buf, p->payload, udp_recv_buf_len);
    pbuf_free(p);
    xil_printf("(<-) Received %lu bytes\r\n", udp_recv_buf_len);
    xSemaphoreGiveFromISR(udp_recv_sem, NULL);
}

int udp_recv_block(uint16_t time) {
	if (xSemaphoreTake(udp_recv_sem, pdMS_TO_TICKS(time)) != pdTRUE) {
		xil_printf("Error: Semamphore timeout (%us)\r\n", time);
		return -1;
	}
	return 0;
}

void read_uart_line(char *msg)
{
	xil_printf("%s", msg);
    uart_in_buf_len = 0;
    while (uart_in_buf_len < UART_IN_BUF_MAX)
    {
        if (XUartPs_IsReceiveData(STDIN_BASEADDRESS)) {
        	uint8_t c = XUartPs_RecvByte(STDIN_BASEADDRESS);
            if (c == '\r' || c == '\n') break;
			xil_printf("%c", c);
			uart_in_buf[uart_in_buf_len++] = c;
        }
    }
    uart_in_buf[uart_in_buf_len] = '\0';
    xil_printf("\r\n");
}

int parse_world_walls(uint8_t *data, uint8_t data_len, WorldWalls *res) {
	if (data_len < 8) {
    	xil_printf("Error: parse_world_walls data_len < 8, actual = %lu\r\n", data_len);
		return -1;
	}
	if (data[0] != 2) {
    	xil_printf("Error: parse_world_walls type != 2, actual = %lu\r\n", data[0]);
		return -1;
	}

	res->type = data[0];
    res->seed = ntohl(*(uint32_t *)(data + 1));
    res->size = ntohs(*(uint16_t *)(data + 5));
	res->num_walls = data[7];

	for (uint8_t i = 0; i < res->num_walls; ++i) {
		res->walls[i].x = ntohs(*(uint16_t *)(data + 8 + i * 6 + 0));
		res->walls[i].y = ntohs(*(uint16_t *)(data + 8 + i * 6 + 2));
		res->walls[i].length = data[8 + i * 6 + 4];
		res->walls[i].direction = data[8 + i * 6 + 5];
	}

	xil_printf("World walls parsed: { %lu, %lu, %lu, %lu }\r\n", res->type, res->seed, res->size, res->num_walls);
	return 0;
}

int parse_world_waypoints(uint8_t *data, uint8_t data_len, WorldWaypoints *res) {
	if (data_len < 8) {
    	xil_printf("Error: parse_world_waypoints data_len < 8, actual = %lu\r\n", data_len);
		return -1;
	}
	if (data[0] != 4) {
    	xil_printf("Error: parse_world_waypoints type != 4, actual = %lu\r\n", data[0]);
		return -1;
	}

	res->type = data[0];
    res->seed = ntohl(*(uint32_t *)(data + 1));
    res->size = ntohs(*(uint16_t *)(data + 5));
	res->num_waypoints = data[7];

	for (uint8_t i = 0; i < res->num_waypoints; ++i) {
		res->waypoints[i].x = ntohs(*(uint16_t *)(data + 8 + i * 6 + 0));
		res->waypoints[i].y = ntohs(*(uint16_t *)(data + 8 + i * 6 + 2));
	}

	xil_printf("World waypoints parsed: { %lu, %lu, %lu, %lu }\r\n", res->type, res->seed, res->size, res->num_waypoints);
	return 0;
}

int parse_world_solution_response(uint8_t *data, uint8_t data_len, WorldSolutionResponse *res) {
	if (data_len != 8) {
    	xil_printf("Error: parse_world_solution_response data_len != 8, actual = %lu\r\n", data_len);
		return -1;
	}
	if (data[0] != 6) {
    	xil_printf("Error: parse_world_solution_response type != 6, actual = %lu\r\n", data[0]);
		return -1;
	}

	res->type = data[0];
    res->seed = ntohl(*(uint32_t *)(data + 1));
    res->size = ntohs(*(uint16_t *)(data + 5));
	res->answer = data[7];

	xil_printf("World solution response parsed: { %lu, %lu, %lu, %lu }\r\n", res->type, res->seed, res->size, res->answer);
	return 0;
}

int write_world_to_mem(uint32_t *ram, WorldWalls *walls, WorldWaypoints *waypoints) {
	memset(ram, 0, HW_MAX_WORDS * sizeof(uint32_t));

	// See RAM schema in definitions section
    uint16_t world_size = waypoints->size;
    ram[0] = (uint32_t)world_size;
    ram[1] = (uint32_t)waypoints->num_waypoints;

    uint32_t *ram_waypoints = &ram[HW_META_WORDS];
	for (uint8_t i = 0; i < waypoints->num_waypoints; ++i) {
        uint16_t x = waypoints->waypoints[i].x;
        uint16_t y = waypoints->waypoints[i].y;
        ram_waypoints[i] = (x << 16) | (y);
	}

    uint32_t *ram_world = &ram[HW_META_WORDS + HW_WAYPOINT_WORDS];
    for (uint8_t i = 0; i < walls->num_walls; ++i) {
        uint16_t x = walls->walls[i].x;
        uint16_t y = walls->walls[i].y;
        uint8_t len = walls->walls[i].length;
        uint8_t dir = walls->walls[i].direction;
        for (uint8_t j = 0; j < len; j++) {
            uint16_t px = x + (dir == 0 ? 0 : j);
            uint16_t py = y + (dir == 0 ? j : 0);
            set_world_bit(ram_world, world_size, px, py, 1);
        }
    }

	return 0;
}

int get_world_bit(uint32_t *world, uint16_t world_size, uint16_t x, uint16_t y) {
    if (x >= world_size || y >= world_size) {
    	xil_printf("Error: get_world_bit coord out of bounds, %lu, %lu outside world of size %lu\r\n", x, y, world_size);
    	return 1;
    }

    uint32_t idx = x + y * world_size;
    uint16_t word = idx / 32;
    uint8_t bit = idx % 32;
    return (world[word] >> bit) & 1;
}

int set_world_bit(uint32_t *world, uint16_t world_size, uint16_t x, uint16_t y, uint8_t value) {
	// This is an expected error case
    if (x >= world_size || y >= world_size) return 1;

    uint32_t idx = x + y * world_size;
    uint16_t word = idx / 32;
    uint8_t bit = idx % 32;
    world[word] |= (value << bit);
    return 0;
}

void debug_print_world_bitmap(uint32_t *ram) {
	uint16_t world_size = ram[0];
	uint16_t num_waypoints = ram[1];

    xil_printf("World Bitmap (%u x %u)\r\n", world_size, world_size);

    // Print waypoint locations
    uint32_t *ram_waypoints = &ram[HW_META_WORDS];
	for (uint8_t i = 0; i < num_waypoints; ++i) {
        uint16_t x = (ram_waypoints[i] >> 16) & 0xFFFF;
        uint16_t y = (ram_waypoints[i]) & 0xFFFF;
        xil_printf("Waypoint %lu at %lu, %lu\r\n", i, x, y);
	}

    // Iterate over each row of the world bitmap
    uint32_t *ram_world = &ram[HW_META_WORDS + HW_WAYPOINT_WORDS];
    for (uint16_t y = 0; y < world_size; ++y) {
        for (uint16_t x = 0; x < world_size; ++x) {
            int bit = get_world_bit(ram_world, world_size, x, y);
            if (bit == -1) {
                xil_printf("Error reading world bit at (%u, %u)\n", x, y);
                return;
            }
            xil_printf("%c", bit == 1 ? 'X' : '.');
        }
        xil_printf("\r\n");
    }
}

int perform_pathfinding(uint32_t *ram) {
    xil_printf("Hardware started: ram[0] = %lu\r\n", ram[0]);

    XToplevel_Set_ram(&hls, (u64) ram);
	Xil_DCacheFlush();
    XToplevel_Start(&hls);
    while(!XToplevel_IsDone(&hls));
    uint32_t code = XToplevel_Get_code(&hls);

    xil_printf("Hardware finished: ram[0] = %lu, code = %lu\r\n", ram[0], code);
    xil_printf("dbg_list: ");
    for (uint16_t i = 0; i < 400; ++i) xil_printf("%lu ", ram[HW_MAX_WORDS - 400 + i]);
    xil_printf("\r\n");

    return 0;
}

// ================================= EXAMPLES =================================

void display_example() {
	// Initialize an array of pointers to the 2 frame buffers
	for (int i = 0; i < DISPLAY_NUM_FRAMES; i++)
		gx_frame_ptrs[i] = gx_frame_buf[i];

	// Initialize, set to frame 0, set resolution, start output
	DisplayInitialize(&gx_dsp_ctrl, XPAR_AXIVDMA_0_DEVICE_ID, XPAR_VTC_0_DEVICE_ID, XPAR_HDMI_AXI_DYNCLK_0_BASEADDR, gx_frame_ptrs, FRAME_STRIDE);
	DisplayChangeFrame(&gx_dsp_ctrl, 0);
	DisplaySetMode(&gx_dsp_ctrl, &VMODE_1440x900);
	DisplayStart(&gx_dsp_ctrl);

	printf("\n\r");
	printf("HDMI output enabled\n\r");
	printf("Current Resolution: %s\n\r", gx_dsp_ctrl.vMode.label);
	printf("Pixel Clock Frequency: %.3fMHz\n\r", gx_dsp_ctrl.pxlFreq);
	printf("Drawing gradient pattern to screen...\n\r");

	// Get parameters from display controller struct
	uint32_t stride = gx_dsp_ctrl.stride / 4;
	uint32_t width = gx_dsp_ctrl.vMode.width;
	uint32_t height = gx_dsp_ctrl.vMode.height;
	uint32_t *frame = (uint32_t *)gx_dsp_ctrl.framePtr[gx_dsp_ctrl.curFrame];
	uint32_t red, green, blue;

	// Fill the screen with a nice gradient pattern
	for (int y = 0; y < height; y++) {
		for (int x = 0; x < width; x++) {
			green = (x*0xFF) / width;
			blue = 0xFF - ((x*0xFF) / width);
			red = (y*0xFF) / height;
			frame[y*stride + x] = (red << BIT_DISPLAY_RED) | (green << BIT_DISPLAY_GREEN) | (blue << BIT_DISPLAY_BLUE);
		}
	}

	// Flush the cache, so the Video DMA core can pick up our frame buffer changes.
	// Flushing the entire cache (rather than a subset of cache lines) makes sense as our buffer is so big
	Xil_DCacheFlush();
	printf("Done.\n\r");
}
